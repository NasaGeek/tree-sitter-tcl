===
Escape blowup
:error
===
# This overloads tree-sitter with choices and errors out. For some reason it's
# never able to reduce down to just one version, possibly due to all the
# conflicts I've defined.
c [l \
]
c [l \
]
c [l \
]
c [l \
]
---

===
Parser deficiency: variable sub empty name
:error
===
puts $::
---

===
Parser deficiency: namespace trailing ::
:error
===
puts $::a::
---

===
Parser deficiency: Full unbraced expressions for while/for/if
:error
===
# Maybe one day can support this.
while 1+1 {}

===
Parser deficiency: Words starting with not-"/{ aren't interpreted literally
:error
===
# Should parse as a single simple_word
puts a{a}

===
Parser deficiency: Too-broad recognition of unpack token
:error
===
# This isn't an unpack, just normal string
puts {*}

===
Parser deficiency: Need spaces in exprs sometimes
:error
===
# As wild as it is, Tcl supports this
expr {$a eq0}

===
Parser deficiency: { as array index
:error
===
set a({) 0

===
Parser deficiency: } as array index
:error
===
set a(}) 0

--------------------------------------------------------------------------------

===
Real error: [ in array index
:error
===
set a([) 1
---

===
Real error: trailing whitespace in array index
:error
===
set a(a ) 1
---

===
Real error: multi-word expr for while
:error
===
while 1 + 1 {}
---

===
Real error: characters after closing quote
:error
===
puts "a"a
---

===
Real error: spaces in array index
:error
===
set arr( a b) 1
---

===
Real error: bare word with int literal as prefix
:error
===
expr {1 eq 1bad}
---

===
Real error: bare word with bool literal as prefix
:error
===
expr {"str" eq falsey}
---

===
Real error: quote concat nuance
:error
===
puts "a"e
---

===
Real error: brace concat nuance
:error
===
puts {a}a
---

===
Real error: bare word with int literal as prefix
:error
===
expr {1 eq 1bad}
---

===
Real error: bare word with bool literal as prefix
:error
===
expr {"str" eq falsey}
---

===
Real error: concat command substitution in braced expr
:error
===
expr {[][]}
---
